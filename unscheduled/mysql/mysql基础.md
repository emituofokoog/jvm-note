

## linux下查看mysql服务的两种方式
1. 方式一：ps -ef|grep mysql
2. 方式二：netstat -nlp

## 二、linux下启动mysql服务的两种方式

命令行方式：
```shell
	cd /usr/bin
	./mysqld_safe &
```
服务方式：
```shell
	service mysql start
	service mysql restart
```
## linux下关闭mysql服务的两种方式：
命令行方式
```shell
	mysqladmin -u root shutdown
```
 服务方式
```shell
	service mysql stop
```

## 读写锁

读锁：共享锁
写锁：排它锁

## 锁粒度
- 表级锁：
	
	开销小，锁定表，粒度大。不会死锁，锁竞争概率高，并发度低，性能最差
	
- 行级锁：
  开销大，加锁慢，锁定一行，粒度小。会出现死锁，锁竞争概率低，并发高，性能高

- 页级锁：
  开销和加锁介于表锁和行锁之间，锁定一页。会出现死锁，锁竞争概率低、并发性、性能介于表锁和行锁之间

## 事务
### 什么是事务

### 事务的四大特性
- 原子性（Atomicity）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

### 事务的并发问题

1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

### MYSQL事务隔离级别

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

### 事务隔离原理
我们都知道事务的几种性质，数据库为了维护这些性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。这里通过分析MySQL中InnoDB引擎的加锁机制，来抛砖引玉，让我们更好的理解，在事务处理中数据库到底做了什么。
### 一次封锁OR两段锁

一次封锁：因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。
两段锁：数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）。

- 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
- 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

```
begin； 
insert into test       # 加insert对应的锁
update test set        # 加update对应的锁
delete from test       # 加delete对应的锁
commit; # 事务提交时，同时释放insert、update、delete对应的锁
```
> 这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。
###### 事务中段加锁方式
在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。

1. Read Uncommitted:任何级别都不会加锁
2. Read Committed:在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read）。
3. Repeatable Read（可重读）
这是MySQL中InnoDB默认的隔离级别。分“读”和“写”两个模块来讲解。
   3.1 读（快照读）


#### 其它阅读资料了解
[BNF范式学习](https://blog.csdn.net/u014287775/article/details/56014778)

[BSON (Binary JSON): Specification](http://bsonspec.org/spec.html)

[BSON与JSON](https://blog.csdn.net/Losteng/article/details/52402775)

